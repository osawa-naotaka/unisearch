# staticseek Example (Astro)

A working demo of this implementation is available at [staticseek-astro.pages.dev](https://staticseek-astro.pages.dev/).

## Getting Started

To run the development server locally:

```bash
npm install
npm run dev
```

Navigate to [http://localhost:4321](http://localhost:4321) in your browser to view the application.

## Deployment

This example is optimized for static file deployment. To generate and deploy the static files:

```bash
npm install
npm run build
# Upload the generated "dist" directory to your HTTP server
```

## Integration Guide: StaticSeek with Astro

### 1. Creating the Search Index

First, create a static index file. The following example demonstrates how to set this up at `src/pages/searchindex.json.ts`:

```typescript
import { getCollection } from "astro:content";
import { GPULinearIndex, StaticSeekError, createIndex, indexToObject } from "staticseek";

export async function GET() {
    const posts = (await getCollection("posts"));
    const linear_index = createIndex(GPULinearIndex, posts, {
        search_targets: ["body", "data.title"],
        key_fields: ["data.title", "id"],
    });

    if (linear_index instanceof StaticSeekError) {
        return new Response(null, { status: 500, statusText: linear_index.message });
    }

    return new Response(JSON.stringify(indexToObject(linear_index)));
}
```

Key configuration points:
- Use `GPULinearIndex` for search functionality (other index types are available)
- Posts are retrieved using Astro's `getCollection` function from the content collection
- Collection directory and schema are defined in `src/content.config.ts`
- Configure `key_fields` to specify which fields should be available in search results (title and id in this example)
- Use `search_targets` to define which fields should be searchable (body and title in this example)
- Index is converted to JSON using `indexToObject` before being returned

### 2. Implementing the Search Interface

Create a search page (e.g., in `src/index.astro`):

```html
---
import Html from "../layout/Html.astro";
---
<Html>
	<section>
		<div class="input-area">
			<div>search</div>
			<input type="text" name="search" id="input-text" placeholder="type your search query in English..." />
		</div>
		<h2>results</h2>
		<ul id="search-result"></ul>
	</section>
</Html>
<script>
import { createSearchFn, StaticSeekError } from "staticseek";
import * as v from "valibot";

const schema = v.object({
	id: v.string(),
	data: v.object({
		title: v.string(),
	}),
});

const search_fn = createSearchFn("/searchindex.json");
const input_text = document.querySelector<HTMLInputElement>("#input-text");
const search_result = document.querySelector<HTMLUListElement>("#search-result");
if(search_result === null) throw new Error("cannot find search-result.");

input_text?.addEventListener("input", async () => {
	const result = await search_fn(input_text.value);
	search_result.innerText = "";
	if(!(result instanceof StaticSeekError)) {
		for(const item of result) {
			const key = v.parse(schema, item.key);
			const li = document.createElement("li");
			li.innerHTML = `<a href="/posts/${key.id}"><h3>${key.data.title}</h3></a><p>${item.refs[0].wordaround}</p>`;
			search_result.appendChild(li);
		}
	}
});
</script>
```

For simplicity, this example uses `innerHTML`. However, in production applications, you should use `createElement` and `appendChild` methods instead of `innerHTML` to mitigate security risks associated with direct HTML injection.

While staticseek operates on the client side, code written in the Astro component's component script section only executes once during deployment. Therefore, staticseek is [implemented within a script element in the component template](https://docs.astro.build/en/guides/client-side-scripts/). 

Important implementation details:
- The search index is loaded only once during first call of `search_fn` generated by `createSearchFn`.
- Search results are sorted by relevance score.
- Each result includes:
  - The key fields specified during index creation (title and slug).
  - The key is parsed using `valibot`.
  - A link to the full post using the id and title of the key fileds.
  - Matched content context via `refs[*].wordaround`.
